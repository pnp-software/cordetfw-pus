/**
 * @file CrPsMonFncPrFunc.c
 * @ingroup man_mon
 *
 * Define functions implementing the Monitoring Function Procedure.
 * This procedure is created and configured in module CrPsMonFncPr.h
 * (this module is automatically generated by the FW Profile Editor).
 *
 * @author Alessandro Pasetti <pasetti@pnp-software.com>
 *
 * @copyright P&P Software GmbH, 2019
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/** CrPsMonFncPr function definitions */
#include "CrPsMonFncPr.h"

/** FW Profile function definitions */
#include "FwPrConstants.h"
#include "FwPrDCreate.h"
#include "FwPrConfig.h"
#include "FwPrCore.h"

/** PUS Framework function definitions */
#include "CrPsMonConfig.h"
#include "Pckt/CrPsPcktMon.h"
#include "DataPool/CrPsDpMon.h"
#include "DataPool/CrPsDpVer.h"
#include "DataPool/CrPsDp.h"
#include "InCmd/CrFwInCmd.h"
#include "UtilityFunctions/CrFwUtilityFunctions.h"
#include "FwPrCore.h"

#include <assert.h>

/** Index for looping through the parameter monitors */
static int i;

/* ----------------------------------------------------------------------------------------------------------------- */
/* Action for node N1. */
void CrPsMonFncPrN1(FwPrDesc_t prDesc) {
    (void)prDesc;
	i = -1;
}

/* ----------------------------------------------------------------------------------------------------------------- */
/* Action for node N2. */
void CrPsMonFncPrN2(FwPrDesc_t prDesc) {
    (void)prDesc;
	i++;
}

/* ----------------------------------------------------------------------------------------------------------------- */
/* Action for node N3. */
void CrPsMonFncPrN3(FwPrDesc_t prDesc) {
    (void)prDesc;
    CrPsParMonCheckStatus_t curMonPrRetVal, prevMonPrRetVal, curCheckStatus;

    /* Execute Monitor Procedure and
    * store its return value in monPrRetVal */
    curCheckStatus = CrPsMonConfigSetMonPrFnc(i)(getDpMonDataItemIdItem[i]);
    setDpMonMonPrRetValItem(i, curCheckStatus);
}

/* ----------------------------------------------------------------------------------------------------------------- */
/* Action for node N4. */
void CrPsMonFncPrN4(FwPrDesc_t prDesc) {
    (void)prDesc;

    /* Increment period counter */
    CrPsMonPer_t temp = getDpMonPerCntItem(i);
    setDpMonPerCntItem(temp+1, 0);
}

/* ----------------------------------------------------------------------------------------------------------------- */
/* Action for node N5. */
void CrPsMonFncPrN5(FwPrDesc_t prDesc) {
    (void)prDesc;
    int j;

    /* Initialize all period counters and repetition counters to zero and
     * checking status to UNCHECKED; initialize Monitor Procedure
     * return value to INVALID */
    for (j=0; j<MON_N_PMON; j++) {
        setDpMonPerCntItem(j, 0);
        setDpMonRepCntItem(j, 0);
        setDpMonCheckStatus(j, MON_UNCHECKED);
        setDpMonMonPrRetValue(j, MON_INVALID);
    }

    /* Initialize monitor index to -1 */
    i = -1;
}

/* ---------------------------------------------------------------------- */
/* Action for node N9. */
void CrPsMonFncPrN9(FwPrDesc_t prDesc) {
    (void)prDesc;
    CrPsParMonCheckStatus_t monPrRetVal;

    /* Update the previous return value of monPrRetVal */
    monPrRetVal = getDpMonMonPrRetValItem(i);
    setDpMonMonPrPrevRetValItem(i, monPrRetVal);
}

/* ---------------------------------------------------------------------- */
/* Action for node N10. */
void CrPsMonFncPrN10(FwPrDesc_t prDesc) {
	(void)prDesc;
    setDpMonPerCntItem(i, 0);
}

/* ---------------------------------------------------------------------- */
/* Action for node N11. */
void CrPsMonFncPrN11(FwPrDesc_t prDesc) {
    (void)prDesc;

    /* Set repetition counter to zero
    * and checking status to INVALID */
    setDpMonRepCnt(i, 0);
    setDpMonCheckStatus(i, MON_INVALID);
}

/* ---------------------------------------------------------------------- */
/* Action for node N12. */
void CrPsMonFncPrN12(FwPrDesc_t prDesc) {
	(void)prDesc;

	/* Set repetition counter to zero */
	setDpMonRepCntItem(i, 0);
}

/* ---------------------------------------------------------------------- */
/* Action for node N13. */
void CrPsMonFncPrN13(FwPrDesc_t prDesc) {
    (void)prDesc;
    CrPsMonPer_t repCnt, repNmb;

    /* Increment repetiion counter
     * with saturation at the repetiion number */
    repCnt = getDpMonRepCntItem(i);
    repNmb = getDpMonRepNmbItem(i);
    if (repCnt < repNmb)
        setDpMonRepCntItem(i, repCnt+1);
}

/* Action for node N14. */
void CrPsMonFncPrN14(FwPrDesc_t prDesc)
{	(void)prDesc;
}

/* Action for node N15. */
void CrPsMonFncPrN15(FwPrDesc_t prDesc)
{	(void)prDesc;
}

/* ---------------------------------------------------------------------- */
/* Guard on the Control Flow from DECISION2 to DECISION6. */
FwPrBool_t CrPsMonFncPrIsParDis(FwPrDesc_t prDesc){
    (void)prDesc;
    if (getDpMonParMonEnbStatusItem(i) == DISABLED)
        return 1;
    else
        return 0;
}

/* ---------------------------------------------------------------------- */
/* Guard on the Control Flow from DECISION4 to DECISION7. */
FwPrBool_t CrPsMonFncPrIsPerSmaller(FwPrDesc_t prDesc) {
	(void)prDesc;
	if (getDpMonPerCntItem(i) < getDpMonPerItem(i))
	    return 1;
	else
	    return 0;
}

/* ---------------------------------------------------------------------- */
/* Guard on the Control Flow from DECISION6 to N1. */
FwPrBool_t CrPsMonFncPrGN1(FwPrDesc_t prDesc) {
    (void)prDesc;
    if (i == (MON_N_PMON-1))
        return 1;
    else
        return 0;
}

/* ---------------------------------------------------------------------- */
/* Guard on the Control Flow from DECISION8 to N11. */
FwPrBool_t CrPsMonFncPrIsParInv(FwPrDesc_t prDesc) {
    CrPsValMask_t maskedValidity;
    CrPsValMask_t expValidityValue;
	(void)prDesc;

    /* A parameter is valid if data item valDataItemId masked with
     * valMask is equal to valExpVal */
	maskedValidity = CrPsMonConfigMaskParVal(getDpMonValDataItemIdItem(i), getDpMonValMask(i));
	expValidityValue = (CrPsValMask_t)getDpMonValExpValue(i);
	if (maskedValidity != expValidityValue)
	    return 1;

	return 0;
}

/* ---------------------------------------------------------------------- */
/* Guard on the Control Flow from DECISION9 to N12. */
FwPrBool_t CrPsMonFncPrIsFlag1(FwPrDesc_t prDesc) {
    (void)prDesc;
    CrPsParMonCheckStatus_t curMonPrRetVal, prevMonPrRetVal;

    /* Execute Monitor Procedure and
     * store its return value in monPrRetVal */
    curMonPrRetVal = getDpMonMonPrRetValItem(i);
    prevMonPrRetVal = getDpMonMonPrPrevRetValItem(i);
    if (curMonPrRetVal != prevMonPrRetVal)
        return 1;
    else
        return 0;
}

/* ---------------------------------------------------------------------- */
/* Guard on the Control Flow from DECISION10 to N14. */
FwPrBool_t CrPsMonFncPrIsFlag2(FwPrDesc_t prDesc) {
    (void)prDesc;
    CrPsParMonCheckStatus_t curCheckStatus, monPrRetVal;
    CrPsMonPer_t repCnt, repNmb;

    /* Flag_2 is true if repetition counter and repetition
     * number are equal and the return value of the
     * Monitor Procedure is different from the monitor's
     * Checking Status (stored in attribute checkStatus) */
    repCnt = getDpMonRepCntItem(i);
    repNmb = getDpMonRepNmbItem(i);
    curCheckStatus = getDpMonCheckStatusItem(i);
    monPrRetVal = getDpMonMonPrRetVal(i);
    if (repCnt == repNmb)
        if (monPrRetVal != curCheckStatus)
            return 1;

    return 0;
}

/* Guard on the Control Flow from DECISION11 to N15. */
FwPrBool_t CrPsMonFncPrIsFlag3(FwPrDesc_t prDesc)
{	(void)prDesc;
    return 1;
}

