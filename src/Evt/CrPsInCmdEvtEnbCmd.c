/**
 * @file
 * @ingroup gen_cfw
 *
 * Implementation of TC(5,5) EvtEnbCmd as an incoming command.
 *
 * The execution of this command extends over N cycles where N is the number of
 * event identifiers held by the command.
 * Each execution cycle is treated as a progress step cycle.
 * The progress step identifier of the n-th execution cycle is equal to n.
 *
 * If an event identifier is encountered to which no severity limit is associated
 * (through function #CrPsEvtConfigGetSeverity), then the application error code
 * is set to: #CrPsEvtIdWithNoSevLevel.
 *
 * @note This file was generated on 2018-10-28 17:05:47
 * @author Automatically Generated by CORDET Editor
 * @copyright P&P Software GmbH
 */

#include "CrPsInCmdEvtEnbCmd.h"
#include "CrPsServTypeId.h"
#include "CrPsTypes.h"
#include "CrPsEvtConfig.h"
#include "DataPool/CrPsDpEvt.h"
#include "Pckt/CrPsPcktEvt.h"

#include "OutRegistry/CrFwOutRegistry.h"
#include "InCmd/CrFwInCmd.h"
#include "UtilityFunctions/CrFwUtilityFunctions.h"

/**
 * Progress action of TC(5,5) EvtEnbCmd.
 * The event identifiers are processed in sequence and in the order in which
 * they are stored in the event report. Each event identifier is processed in
 * an execution cycle. Each execution cycle counts as a progress step. At each
 * execution, the progress action performs the following actions:
 *
 * (a) If the event identifier is illegal, then: the illegal EID is loaded
 * into verFailData and the Success Outcome is set to VER_ILL_EID
 * (b) If the event identified is legal, then: its enable status is set to
 * 'enabled'; the value of nDisabledEid x (’x’ is the severity level of the
 * EID) is decremented; and the Success Outcome of the action is set to
 * 'success'
 * (c) The Completion Outcome of the action is set to 'completed' if all event
 * identifiers carried by the command have been processed; otherwise it is set
 * to 'not completed'.
 *
 * The enable status of the event identifier is stored in the OutRegistry
 * component of the Cordet Framework.
 * @param smDesc The state machine descriptor.
 */
void CrPsInCmdEvtEnbCmdProgressAction(FwSmDesc_t smDesc) {
   CrFwPckt_t evtPckt = CrFwOutCmpGetPckt(smDesc);
   static CrPsNEvtId_t nEvtId;
   static CrFwCmdRepIndex_t cmdRepIndex;
   static CrFwDiscriminant_t lowerBound, upperBound;
   CrPsEvtId_t eid;
   unsigned int sevLevel;
   CrFwProgressStepId_t progressStepId;
   CrPsNEvtId_t nOfDisabledEvt;

   /* Get the progress step identifier */
   progressStepId = CrFwInCmdGetProgressStepId(smDesc);

   /* Actions done only in first execution cycle */
   if (progressStepId == 0) {
     /* Get the lower and upper bounds for the event identifier */
     cmdRepIndex = CrFwOutRegistryGetCmdRepIndex(EVT_TYPE, 1);
     lowerBound = CrFwOutRegistryGetLowerDiscriminant(cmdRepIndex);
     upperBound = CrFwOutRegistryGetUpperDiscriminant(cmdRepIndex);
     /* Get the number of EIDs in the command */
     nEvtId = getEvtEnbCmdN(evtPckt);
   }

   /* Get the event identifier to be process in the current cycle */
   eid = getEvtEnbCmdEventId(evtPckt, progressStepId);

   if ( eid > upperBound)
     CrFwSetSmOutcome(smDesc, VER_ILL_EID);
   else if ( eid < lowerBound)
     CrFwSetSmOutcome(smDesc, VER_ILL_EID);
   else {
     sevLevel = CrPsEvtConfigGetSeverity(eid);
     switch (sevLevel) {
       case 1:
         CrFwOutRegistrySetEnable(EVT_TYPE,sevLevel,eid,1);
         nOfDisabledEvt = getDpEvtNOfDisabledEid_1();
         setDpEvtNOfDisabledEid_1(nOfDisabledEvt+1);
         break;
       case 2:
         CrFwOutRegistrySetEnable(EVT_TYPE,sevLevel,eid,1);
         nOfDisabledEvt = getDpEvtNOfDisabledEid_2();
         setDpEvtNOfDisabledEid_1(nOfDisabledEvt+1);
         break;
       case 3:
         CrFwOutRegistrySetEnable(EVT_TYPE,sevLevel,eid,1);
         nOfDisabledEvt = getDpEvtNOfDisabledEid_3();
         setDpEvtNOfDisabledEid_1(nOfDisabledEvt+1);
         break;
       case 4:
         CrFwOutRegistrySetEnable(EVT_TYPE,sevLevel,eid,1);
         nOfDisabledEvt = getDpEvtNOfDisabledEid_4();
         setDpEvtNOfDisabledEid_1(nOfDisabledEvt+1);
         break;
       default:
         CrFwSetAppErrCode(CrPsEvtIdWithNoSevLevel);
     }
     CrFwSetSmOutcome(smDesc, 1);
   }

   /* Update progress step identifier */
   progressStepId++;
   CrFwInCmdSetProgressStepId(smDesc, progressStepId);

   /* Set completion outcome */
   if (progressStepId < nEvtId)
     CrFwInCmdSetProgressActionCompleted(smDesc, 0);
   else
     CrFwInCmdSetProgressActionCompleted(smDesc, 1);
}
