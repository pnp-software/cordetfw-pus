__author__ = 'Alessandro Pasetti, P&P software GmbH'

#===============================================================================
# Convenience functions to support the code generator.
#===============================================================================

import sys
import os
import argparse
import shutil
import csv
import pdb
import json
import operator
import re
import copy
import zipfile
import datetime;

from Config import tmPcktHeaderLen, tcPcktHeaderLen, pcktCrcLen, pcktToPcktPars,
                   derPcktToPcktPars


#===============================================================================
# Return the spec_item name as 'Domain:Name'.
def getSpecItemName(specItem):
    return specItem['domain'] + ':' + specItem['name']


#===============================================================================
# Return the length in bits of a packet parameter.
def getPcktParLen(pcktPar):
    pcktParDataItem = specItems[pcktPar['s_link']]
    pcktParDataItemType = specItems[pcktParDataItem['p_link']]
    return pcktParDataItemType['n1']


#===============================================================================
# Return the type and sub-type of the argument packet as a tuple (x,y).
# The argument can be one of: a packet, a derived packet, a telecommand or a
# telemetry report.
def getTypeAndSubType(specItem):
    if specItem['cat'] == 'Packet':
        service = specItem['p_link']
        servType = specItems[service]['value']
        servSubtype = specItem['value']
        return (servType, servSubStype)
        
    if specItem['cat'] == 'DerPacket':
        parentPckt = specItems[specItem['s_link']]
        if parentPckt['cat'] != 'Packet':
            print('ERROR: Database is corrupted: parent of '+specItem['name']+' is also a Derived Packet')
            return (0, 0)
        return getTypeAndSubType(parentPckt)
        
    if specItem['cat'] == 'InCommand' or specItem['cat'] == 'OutComponent':
        packet = specItems[specItem['p_link']]
        if packet['cat'] != 'Packet':
            print('ERROR: Database is corrupted: packet of InCommand/OutComponent '+specItem['name']+' is not a Packet')
            return (0, 0)
        return getTypeAndSubType(packet)
        
    return (0,0)


#===============================================================================
# Return the value of the discriminant of the argument derived packet.
def getDiscVal(derPacket):
    disc = derPacket['p_link']
    if disc['cat'] != 'DataItem':
        print('ERROR: Derived packet '+derPacket['name']+' has a discriminant which is non a data item') 
        return 0
    return disc['value']
        

#===============================================================================
# Return the length in bits of a packet.
def getPcktLen(specItem):
    if specItem['cat'] == 'Packet':
        pcktName = getSpecItemName(specItem)
        pcktLen = 0
        for pcktPar in pcktToPcktPars[pcktName]:
            pcktLen = pcktLen + getPcktParLen(pcktPar)
        if specItem['p_kind'] == 'TC':
            return pcktLen + tcPcktHeaderLen + pcktCrcLen
        else:
            return pcktLen + tmPcktHeaderLen + pcktCrcLen
    
    if specItem['cat'] == 'DerPacket':
        pcktName = getSpecItemName(specItem)
        parentPckt = specItems[specItem['s_link']]
        if parentPckt['cat'] != 'Packet':
            print('ERROR: Database is corrupted: parent of '+pcktName+' is also a Derived Packet')
            return 0
        parentPcktLen = getPcktLen(specItem)
        pcktLen = 0
        for pcktPar in derPcktToPcktPars[pcktName]:
            pcktLen = pcktLen + getPcktParLen(pcktPar)
        return parentPcktLen + pcktLen


#===============================================================================
# Create a header file with the given name and the given content.
def createHeaderFile(dirName, fileName, content):
    name = dirName + '/' + fileName
    ct = datetime.datetime.now()
    ifdefName = fileName[:-2].replace('_','').upper()
    with open(name, 'w') as fd:
        fd.write('/**                                          \n')
        fd.write(' * @ingroup gen_cfw                          \n')
        fd.write(' *                                           \n')
        fd.write(' * This file is part of the PUS Extention of the  CORDET Framework \n')
        fd.write(' *                                           \n')
        fd.write(' * @note This file was generated on  ' + ct + '\n')
        fd.write(' * @author Automatically generated by CORDET Editor Generator\n')
        fd.write(' * @copyright P&P Software GmbH\n')
        fd.write(' */                                          \n')
        fd.write('#ifndef ' + fileName[:-2].replace('_','').upper() + '_H_\n')
        fd.write('#define ' + fileName[:-2].replace('_','').upper() + '_H_\n')
        fd.write('\n')
        fd.write(content)
        fd.write('#endif /* ' + fileName[:-2].replace('_','').upper() + '_H_ */\n')
        
