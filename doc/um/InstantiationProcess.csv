ID|Title|SpecificationStep|Sect|ImplementationStep
1|Identify Target Application|Identify the application for which the framework is being instantiated. ||The Application Identifier is specified in \texttt{CrFwUserConstants.h}.
2|Identify Service Users |Identify the users of the services provided by the target application. Each service user is identified through its Application Identifier.  ||The service user identifiers are used to define the sources of incoming commands (InCommands) for the application in \texttt{CrFwInStreamUserPar.h} and the destination of out-going reports (OutCompnents) in \texttt{CrFwOutStreamUserPar.h}.
3|Identify Service Providers |Identify the providers of the services used by the target application. Each service provider is identified through its Application Identifier. ||The service provider identifiers are used to define the sources of incoming reports (InReports) for the application in \texttt{CrFwInStreamUserPar.h} and the destination of out-going commands (OutCompnents) in \texttt{CrFwOutStreamUserPar.h}.
4|Define Used Services |Define the services which are used by the target application. Each service is defined through: its identifier (the "service type"); a description of the purpose of the service; the external entity which provides the service; the commands and reports which implement the service. ||The range of services used by the application is defined in \texttt{CrFwInFactoryUserPar.h} and \texttt{CrFwOutFactoryUserPar.h}. Also, a list of services supported by the application is defined in \texttt{CrFwOutRegistryUserPar.h}.
5|Define Provided Services |Define the services which are provided by the target application. Each service is defined through: its identifier (the "service type"); a description of the purpose of the service; the external entity which uses the service; the commands and reports which implement the service.  ||The range of services provided by the application is defined in \texttt{CrFwInFactoryUserPar.h} and \texttt{CrFwOutFactoryUserPar.h}. Also, a list of services supported by the application is defined in \texttt{CrFwOutRegistryUserPar.h}.
5.1|Select Pre-Defined Provided Services|From the services provided by the PUS Extension, select those which are to be included in the target application. Note that it is not possible to select only a sub-set of the commands and reports of a supported service: once a pre-defined service is selected for inclusion in the target application, all its commands and reports are imported.||Services supported by the PUS Extension are identifier by a 2- or 3-letter acronym. The code implementing service Xyz is spread over three locations: (a) the code implementing the commands and reports for supported service Xyz is in directory \texttt{src/Xyz}; (b) the data pool items belonging to that service are in module: \texttt{src/DataPool/CrPsDpXyz}; (c) the packet accessor functions are in module \texttt{src/Pckt/CrPsPcktXyz}. 
5.2|Customize the Selected Pre-Defined Services|For the selected services pre-defined by the PUS Extension, define: (a) the value of their constatns; (b)  the size of the types of their data pool items and packet parameters; and (c) the endianity of its packet parameters.||The PUS Extension constants are defined in file \texttt{CrPsConstants.h}. The size of the data types are defined in \texttt{CrPsTypes.h}. A change of endianity requires update of all packet accessor functions in: \texttt{CrFwPckt.h}, in all the \texttt{CrPsPcktXyz.h}} and in the \texttt{getDpValueEx} function.
5.3|Define Command Rejection Codes|If the target application supports the Command Verification Service pre-defined by the PUS Extension, define the command rejection codes supported by the application in terms of their identifiers and of their verification data item.||The range of command rejection codes is defined in enumerated type \texttt{CrPsFailCode\_t}.
5.4|Define Event Reports|If the target application supports the Event Reporting Service pre-defined by the PUS Extension, define the event reports supported by the application in terms of their event identifiers, of their severity level, and of the parameters they carry.||The range of event identifiers is defined in enumerated type \texttt{CrPsEvtId\_t}. A change in the set of event identifiers requires the module \texttt{CrPsPcktEvt.h} to be re-generated. 
6|Identify Re-Routing Capabilities |Define the applications to which incoming packets received must be re-routed. |\ref{sec:PcktInterface}|The re-routing information is defined in the re-routing function which is provided to the framework as a function pointer in \texttt{CrFwInLoaderUserPar.h} and for which two defaults are provided by the InLoader component. Also, re-routing contributes to the definition of InStreams and OutStreams (InStreams are required to receive re-routed packets and OutStreams are required to forward them).
7|Define Incoming Commands|For each provided service not pre-defined by the PUS Extension, define the commands which implement it (i.e the commands which the application must be able to receive and process) in terms of: their attributes, their acceptance and ready checks, their start action, progress action, termination action, and abort action.|\ref{sec:InCommand}|The detailed definition of the incoming commands is done in \texttt{CrFwInFactoryUserPar.h}. Also, for each command, a C-module must be provided which implements the functions encapsulating the command actions and checks. See the command modules pre-defined by the PUS Extension for an example. 
8|Define Incoming Reports |For each used service, define the reports which implement it (i.e. the reports which the application must be able to receive and process) in terms of: their attributes, their acceptance check, and their update action.  |\ref{sec:InReport}|The detailed definition of the incoming reports is done in \texttt{CrFwInFactoryUserPar.h}. Also, for each report, a C-module must be provided which implements the functions encapsulating the report actions and checks. See module \texttt{CrFwInRepSample1} for an example.
9|Define Outgoing Commands and Reports|For each provided service not pre-defined by the PUS Extension, define the reports which implement it and for each used service, define the commands which implement it in terms of: their attributes, their enable check, and their ready, and repeat check and their update action.|\ref{sec:OutComponent}|The detailed definition of the out-going commands and reports is done in \texttt{CrFwOutFactoryUserPar.h}. Also, for out-going reports or commands which do not use the default implementations of the OutComponent adaptation points, a C-module must be provided which implements the functions encapsulating the report or command actions and checks. See module \texttt{CrFwOutCmpSample1} for an example.
10|Assign Commands and Reports to Groups|Define command and report groups and define rules for assigning commands and reports to groups.||The definition of the assignment rules is done in the implementation of the getter and setter functions for the group attribute in module \texttt{CrFwPckt}. 
11|Define Command and Report Layout|For each command and report which can be either generated or received by the target application, define the layout of the packet which carries it.|\ref{sec:PcktImpl}|The packet layout is implicitly implemented in the setter and getter functions of the \texttt{CrFwPckt.h} interface. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.
12|Define Packet Allocation Policy|Define the allocation policy for the packets which the application creates when it receives a command or report.|\ref{sec:PcktImpl}|The packet allocation policy is implemented in the \texttt{make} function of the \texttt{CrFwPckt.h} interface. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.
13|Define Command and Report Capacity|Define: the maximum number of incoming commands which the target application can hold at any given time; the maximum number of incoming reports which the target application can hold at any given time; and the maximum number of outgoing commands or reports which the application can hold at any given time. ||The capacities for incoming commands and reports are defined as \texttt{\#DEFINE} constants in \texttt{CrFwInFactoryUserPar.h}. The capacity for out-going commands and reports is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwOutFactoryUserPar.h}.
14|Define Application Modes|Define the sub-states in the states of the Application State Machine.|\ref{sec:AppStartUp}|For each set of sub-states, a state machine implementing them is defined which is then embedded in one of the states of the Application State Machine. The embedded state machines are defined in \texttt{CrFwAppSmUserApp.h}. 
15|Define Incoming Middleware Interface|Define the interface to the middleware which is responsible for receiving the commands and reports for the target application.|\ref{sec:InStream}|For each source of commands or reports, one InStream is defined. The size of the InStream packet queues and the pointers to the functions which implement the InStream operations are defined in \texttt{CrFwInStreamUserPar.h}. Also, for each InStream a C module must be defined which implements the InStream functions. A test stub is provided in \texttt{CrFwInStreamStub}.
16|Define Out-Going Middleware Interface|Define the interface to the middleware which is responsible for sending the commands and reports originating in the target application.|\ref{sec:OutStream}|For each command or report destination, one OutStream is defined. The size of the OutStream packet queues and the pointers to the functions which implement the OutStream operations are defined in \texttt{CrFwOutStreamUserPar.h}. Also, for each OutStream a C module must be defined which implements the OutStream functions. A test stub is provided in \texttt{CrFwOutStreamStub}.
17|Define InManagers|Define the number of InManagers and the size of their Pending Command/Report Lists (PCRLs).||These items are defined as \texttt{\#DEFINE} constants in \texttt{CrFwInManagerUserPar.h}
18|Define InManager Selection Function|Define the logic to select the InManager where an incoming command or report is loaded.|\ref{sec:InLoader}|A pointer to this function is defined in \texttt{CrFwInLoaderUserPar.h}. A default implementation is provided by the InLoader (see \texttt{CrFwInLoader.h}).
19|Define InRegistry|Define the maximum number of commands and reports which can be tracked by the InRegistry.||This item is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwInRegsitryUserPar.h}.
20|Define OutManagers|Define the number of OutManagers and the size of their Pending OutComponent Lists (POCLs).||These items are defined as \texttt{\#DEFINE} constants in \texttt{CrFwOutManagerUserPar.h}.
21|Define OutManager Selection Function|Define the logic to select the OutManager where an out-going command or report is loaded.|\ref{sec:OutLoader}|A pointer to this function is defined in \texttt{CrFwOutLoaderUserPar.h}. A default implementation is provided by the OutLoader (see \texttt{CrFwOutLoader.h}).
22|Define OutRegistry|Define the maximum number of commands and reports which can be tracked by the OutRegistry.||This item is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwOutRegistryUserPar.h}.
23|Define Start-Up Procedure|Define the start-up procedure for the application. This in particular includes the sequence in which framework components are instantiated, initialized and configured.|\ref{sec:AppStartUp}|Implement the Application Start-Up Procedure by providing an implementation for \texttt{CrFwAppStartUpProc.h}. A test stub is provided in \texttt{CrFwAppStartUpProc.c}.
24|Define Reset Procedure|Define the reset procedure for the application. This in particular includes the sequence in which framework components are reset.|\ref{sec:AppStartUp}|Implement the Application Reset Procedure by providing an implementation for \texttt{CrFwAppResetProc.h}. A test stub is provided in \texttt{CrFwAppResetProc.c}.
25|Define Shutdown Procedure|Define the shutdown procedure for the application. This in particular includes the sequence in which framework components are shutdown.|\ref{sec:AppStartUp}|Implement the Application Shutdown Procedure by providing an implementation for \texttt{CrFwAppShutdownProc.h}. A test stub is provided in \texttt{CrFwAppShutdownProc.c}.
26|Define Time Interface|Define the means through which the current time is acquired. This is needed for time-stamping out-going commands and reports in the OutStream.||The time acquisition interface is defined in \texttt{CrFwTime.h}. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.
27|Define Error Reporting Interface|Define the response to the generation of error reports.||The respone to error reports is defined in \texttt{CrFwRepErr.h}. The application developer must provide a complete implementation for this interface. A test implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.
28|Define InCommand Outcome Reporting|Define the means through which the outcome of the processing of incoming commands is reported. ||The respone to the reports of InCommand outcomes is defined in \texttt{CrFwRepInCmdOutcome.h}. The application developer must provide a complete implementation for this interface. A test implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.
29|Define Primitive Types|Define the range of the primitive types used by the framework components. The driver for this definition is the need to optimize the memory footprint of the application.||The primitive types are defined through \texttt{typedef}'s in \texttt{CrFwUserConstants.h}. Application developers can override the default definitions in this file (but note that, in most cases, the default definitions should be adequate).
